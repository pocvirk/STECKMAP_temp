Tools for Stellar Content and Kinematics Analysis

INSTALLING:

- (1) install yorick. It is important for this version that yorick be installed in the Yorick/ directory such as:
<user-home>/Yorick/
Successful installation should result in the yorick executable to have a full path similar to:
<user-home>/Yorick/yorick-1.6/yorick/yorick
(for yorick-1.6 that is)

this note provides few guidelines for installing
yorick. Refer to yorick's README for more.
I however recommend using yorick through emacs. Follow the yorick.el instructions to do so. You will need to make a straightforward modification of your ~/.emacs. and inside yorick.el dont forget to provide the full path to the yorick executable (search for the string "yorick-executable-name" and replace the adjacent string "yorick" with the full path to the executable).

- (2) in your home directory, untar the ToSCKA archive
tar -xvf ToSCKA.tar
this will unpack the archive and generate the necessary arborescence in Yorick/
Some routines use the environment variable HOME to define absolute paths to some objects, so be sure it is correctly defined by typing in a shell:
echo $HOME
although if it wasn't properly defined you would probably be in big trouble...


RUNNING ToSCKA:

- launch yorick by typing "yorick" on the shell command line
if yorick does not launch, go back to (1)

- once, yorick has launched, load ToSCKA by typing 
include, "Pierre/POP/sfit.i"


GET STARTED WITH AN EXAMPLE:

You will find a couple of example data in Yorick/Pierre/POP/EXAMPLES/.
They are provided in order to give the user a taste of what can be done
and how to proceed. Follow this small tutorial.

ToSCKA is a tool package aiming at constraining the stellar content and
kinematics from galaxy spectra. To do so, you need two things:
* DATA (of course)
* Models against which to compare your data

The first thing to do is to get your data in a format that sfit will
understand, and that provides all necessary side-data (SNR, error
vectors, masks...). Then
you will need to
create a basis of SSPs that will be
combined to match your data. Then you will want to compare your data with
the models. Routines are provided for these 3 steps. They form the core of
ToSCKA.

I - CONVERTING THE DATA: .fits to .pdb
Conversion routines and examples are provided for .fits data. Examples of
conversion and the content of a .pdb data file are provided in
Pierre/POP/conv2ls.i  (read "2ls" as "tools").
Successful data file conversion involves two steps:
 * creating and filling up the gal_Struct structure for your galaxy.
 * Creating the vectors flux (flux), wave (wavelength), sigm (optional, containing the errors), and mask (optional as well).
I will soon publish a general-purpose .fits to .pdb conversion routine using the relevant fits keywords to prevent users from having to learn yorick

With an example .fits file. See the path and name of the file by typing
> fV
fV is just a variable storing the path and name of the example file, to make things faster.
Convert the example file using convertVAKU:
> a=convertVAKU(fV)

this will create the .pdb file, plot the data, and print the redshdift of the example galaxy.


II - GENERATE A SSP BASIS

A basis is a structure as defined in "Pierre/POP/base_struct.i". This structure contains the sequence of SSPs in time and metallicity. As such, it is a data cube. The structure contains this cube and also the wavelengths, the resolution, the metallicity scale, and the ages of wach element of the basis.

To generate a basis, use the function bRbasis:
> b=bRbasis()

This will call bRbasis with all the defaults arguments (type > help,bRbasis to get help and see information about the various arguments and their default values). Here the default is a basis with 10 age bins from 10Myr to 20 Gyr with Salpeter IMF and Padova tracks. It is flux-normalized by default (see the STECMAP paper for details). It is generated by PEGASE-HR so R=10000 and the wavelength coverage is 4000-6900 A. All these values can of course be changed when calling bRbasis.

To have an idea of the looks of your brand new basis, type
> ws  
this is to clear the display
> plb, b.flux(,,1),b.wave
This will result in a nice plot of the basis for the first metallicity of the basis. It can be printed by typing:
> b.met(1) 
since the metallicities are stored in b.met. Note that for computational reasons, the metallicities are renormalized. Hence, you can read the original metallicity of the first constant-metallicity slice of the SSP cube b.flux(,,1) by typing:
> Zrescalem1(b.met(1))
it should be 0.05.

We are now set for the big game.


III - FIT THE DATA

The fitting engine is called with the sfit command, which takes as arguments, the data, the basis and a bunch of options. Type 
> help,sfit
to see the current documentation for sfit.
To fit the data, the structure of which is stored in the variable a, using the SSP basis, the structure of which is stored in the variable b, type:
> x=sfit(a,b)
If you get a message of the kind "skipping..." then it means you already have a results file for this data. Force the computation by adding the option noskip=1:
> x=sfit(a,b,noskip=1,sav=1)
The additional option sav=1 tells sfit to save the results.
You will see columns of number (just like in Matrix) showing the minimization process of the objective function.
Check the displays to see the data (black), the fit (red), and the mask (blue).
This doesn't look very good, especially since the models are at much higher resolution than the data. This will allow us to investigate the kinematics of the galaxy. The LOSVD research features of sfit will be set on by the option kin=1:
> x=sfit(a,b,kin=1,noskip=1,sav=1)

This is already better. But now the residuals seem to be dominated by some flux calibration error. By default, the extinction law is taken from Calzetti 1999, which does not account for possible calibration errors. A special way to deal with that has been introduced as NPEC. Set it on by using the option epar=3. The number of anchor points is specified by nde. nde=10 by default. Type:
> x=sfit(a,b,kin=1,epar=3,nde=100,noskip=1,sav=1)

Woohoo! The residuals are cut by 2 or 3.

Work is in progress to produce shell command lines scripts, in order to eventually have the yorick part totally hidden, and the user issuing exclusively shell commands.


Pierre OCVIRK, 10th of Oct. 2005

